/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "Ucglib.h"
#include "temhumsensor.h"
#include "timer.h"
#include "stm32f401re_i2c.h"
#include "string.h"
#include "stdio.h"
#include "stm32f401re_rcc.h"
#include "stm32f401re_gpio.h"
#include "misc.h"

/* LCD define-------------------------------------------------------------------------------------------------*/
#define SPI1_CS_PORT		GPIOB
#define SPI1_CS_PIN			GPIO_Pin_6
#define SPI1_RST_PORT		GPIOC
#define SPI1_RST_PIN		GPIO_Pin_7
#define SPI1_MOSI_PORT		GPIOA
#define SPI1_MOSI_PIN		GPIO_Pin_7
#define SPI1_SCK_PORT		GPIOA
#define SPI1_SCK_PIN		GPIO_Pin_5
#define SPI1_RS_PORT		GPIOA
#define SPI1_RS_PIN			GPIO_Pin_9
#define SPI1_ENABLE_PORT	GPIOB
#define SPI1_ENABLE_PIN		GPIO_Pin_10
#define SPI1_MODE_PORT		GPIOA
#define SPI1_MODE_PIN		GPIO_Pin_8

/* TemHum define---------------------------------------------------------------------------------------------*/
#define I2C_MASTER_RCC					RCC_APB1Periph_I2C1
#define I2C_MASTER						I2C1

#define I2C_MASTER_GPIO_RCC				RCC_AHB1Periph_GPIOB
#define I2C_MASTER_PORT					GPIOB
#define SDA_MASTER_PIN					GPIO_Pin_9 // PB9
#define SCL_MASTER_PIN					GPIO_Pin_8 // PB8

#define SENSOR_SLAVE					((I2C_TypeDef *) 0x40)
#define SENSOR_SLAVE_ADDR				0x80

#define I2C_SPEED						400000 // 400 KBit/s

#define WRITE							I2C_Direction_Transmitter
#define READ							I2C_Direction_Receiver
#define CMD_HUMI_HOLD					0xE5 // hold master mode
#define CMD_TEM_HOLD					0xE3 // hold master mode

/* Variables--------------------------------------------------------------------------------------------------*/
uint32_t time_initial = 0;
ucg_t ucg;
static uint8_t temperture=0,humidity=0;
static char str1[20]="";
static char str2[20]="";
static SSwTimer Sensor= NO_TIMER;
/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	I2C_InitMaster
 *
 * @brief	Initialization I2C master mode
 *
 * @param	none
 *
 * @retval	none
 */
void I2C_InitMaster()
{
	I2C_InitTypeDef I2C_InitStruct;
	GPIO_InitTypeDef GPIO_InitStruct;

	// cấu hình GPIO ở chế độ Open Drain----------------------------------------------------------------------
	RCC_APB1PeriphClockCmd(I2C_MASTER_RCC,ENABLE);
	RCC_AHB1PeriphClockCmd(I2C_MASTER_GPIO_RCC,ENABLE);

	GPIO_InitStruct.GPIO_Mode	= GPIO_Mode_AF;
	GPIO_InitStruct.GPIO_Speed	= GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_OType	= GPIO_OType_OD;
	GPIO_InitStruct.GPIO_PuPd	= GPIO_PuPd_UP;

	GPIO_InitStruct.GPIO_Pin	= SCL_MASTER_PIN | SDA_MASTER_PIN;
	GPIO_Init(I2C_MASTER_PORT,&GPIO_InitStruct);

	// kết nối PB8 tới I2C1_SCL và PB9 tới I2C1_SDA-----------------------------------------------------------
	GPIO_PinAFConfig(I2C_MASTER_PORT, GPIO_PinSource8, GPIO_AF_I2C1);
	GPIO_PinAFConfig(I2C_MASTER_PORT, GPIO_PinSource9, GPIO_AF_I2C1);

	// cấu hình I2C--------------------------------------------------------------------------------------------
	I2C_InitStruct.I2C_ClockSpeed			= I2C_SPEED;
	I2C_InitStruct.I2C_Mode					= I2C_Mode_I2C;
	I2C_InitStruct.I2C_DutyCycle			= I2C_DutyCycle_2;
	I2C_InitStruct.I2C_OwnAddress1			= 0x00;
	I2C_InitStruct.I2C_Ack					= I2C_Ack_Enable;
	I2C_InitStruct.I2C_AcknowledgedAddress	= I2C_AcknowledgedAddress_7bit;

	I2C_Init(I2C_MASTER, &I2C_InitStruct);
	I2C_Cmd(I2C_MASTER, ENABLE);

}
/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	I2C_start
 *
 * @brief	Generate START condition
 *
 * @param	none
 *
 * @retval	none
 */
static void I2C_start()
{
	// wait until I2Cx is not busy anymore
	while(I2C_GetFlagStatus(I2C_MASTER, I2C_FLAG_BUSY));

	// Generate start condition
	I2C_GenerateSTART(I2C_MASTER, ENABLE);

	// Wait for I2C EV5
	// It means that the start condition has been correctly released
	// on the I2C bus (the bus is free, no other  devices is communicating)

	while(!I2C_CheckEvent(I2C_MASTER, I2C_EVENT_MASTER_MODE_SELECT));
}

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	I2C_Address_Direction
 *
 * @brief	send address and direction to slave
 *
 * @param	none
 *
 * @retval	none
 */
static void I2C_Address_Direction(uint8_t address, uint8_t direction)
{
	//address = 1<<address;
	I2C_Send7bitAddress(I2C_MASTER, address, direction);
	// truyền địa chỉ xuống Slave
	if(direction == WRITE)
	{
		while(!I2C_CheckEvent(I2C_MASTER, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
//		I2C_ClearFlag(SENSOR_SLAVE, I2C_FLAG_ADDR);
	}
	else// direction == READ
	{
		while(!I2C_CheckEvent(I2C_MASTER, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
//		I2C_ClearFlag(SENSOR_SLAVE, I2C_FLAG_ADDR);
	}
}

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	I2C_Transmit_CMD
 *
 * @brief	send read command to slave
 *
 * @param	none
 *
 * @retval	none
 */
static void I2C_Transmit_CMD(uint8_t cmd)
{
	 // Send command
	 I2C_SendData(I2C_MASTER, cmd);
	 // Wait for I2C EV8_2.
	 // It means that the data has been physically shifted out and
	 // output on the bus
	 while(!I2C_CheckEvent(I2C_MASTER, I2C_EVENT_MASTER_BYTE_TRANSMITTED));

}

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	I2C_Stop
 *
 * @brief	Generate STOP condition
 *
 * @param	none
 *
 * @retval	none
 */
static void I2C_Stop()
 {
	 // Generate I2C stop condition
	 I2C_GenerateSTOP(I2C_MASTER, ENABLE);
 }

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	I2C_Receive_Ack
 *
 * @brief	receive MS Byte
 *
 * @param	none
 *
 * @retval	MS Byte
 */
static uint8_t I2C_Receive_Ack()
{
	uint8_t data = 0;
	I2C_AcknowledgeConfig(I2C_MASTER,ENABLE);
	while(!I2C_CheckEvent(I2C_MASTER, I2C_EVENT_MASTER_BYTE_RECEIVED));
	data = I2C_ReceiveData(I2C_MASTER);
	return data;
}

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	I2C_Receive_Nack
 *
 * @brief	receive LS Byte
 *
 * @param	none
 *
 * @retval	LS Byte
 */
static uint8_t I2C_Receive_Nack()
{
	uint8_t data = 0;
	I2C_AcknowledgeConfig(I2C_MASTER,DISABLE);
	while(!I2C_CheckEvent(I2C_MASTER, I2C_EVENT_MASTER_BYTE_RECEIVED));
	data = I2C_ReceiveData(I2C_MASTER);
	return data;
}

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	TemHumSensor_readRegister
 *
 * @brief	read data in register sensor
 *
 * @param	[slave_Address]: address of sensor
 * @param	[cmd]: command to read
 *
 * @retval	none
 */
static uint16_t TemHumSensor_readRegister(uint8_t slave_Address,uint8_t cmd)
{
	uint8_t data_temp1 = 0;
	uint8_t data_temp2 = 0;
	uint16_t data = 0 ;
	// Generate start
	I2C_start();

	// send address with write mode
	I2C_Address_Direction(slave_Address,WRITE);
	// send command to slave
	I2C_Transmit_CMD(cmd);

	// rep Start
	I2C_Stop();
	I2C_start();

	// send address with read mode
	I2C_Address_Direction(slave_Address,READ);

	// MS Byte
	data_temp1 = I2C_Receive_Ack();

	//LS Byte
	data_temp2 = I2C_Receive_Nack();

	// Generate stop
	I2C_Stop();

	data |= (uint16_t) (data_temp1<<8);
	data |= (uint16_t) (data_temp2<<0);

	return data;
}

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	TemHumSensor_getTemperature
 *
 * @brief	Get data of Temperature
 *
 * @param	none
 *
 * @retval	value of Temperature
 */
static uint16_t TemHumSensor_getTemperature()
{
	uint16_t data = 0,temp = 0;

	temp = TemHumSensor_readRegister(SENSOR_SLAVE_ADDR,CMD_TEM_HOLD);
	data = (17572*temp/65536) - 4685;

	return data;
}

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	TemHumSensor_getHumidity
 *
 * @brief	Get data of humidity
 *
 * @param	none
 *
 * @retval	value of humidity
 */
static uint16_t TemHumSensor_getHumidity()
{
	uint16_t data = 0,temp = 0;

	temp = TemHumSensor_readRegister(SENSOR_SLAVE_ADDR,CMD_HUMI_HOLD);
	data = (125*temp/65536) - 6;

	return data;
}

/* Function---------------------------------------------------------------------------------------------------*/
/**
 * @func	processGetValueSensor
 *
 * @brief	Get value sensor
 *
 * @param	none
 *
 * @retval	none
 */
void processGetValueSensor()
{
	temperture=(uint8_t)(TemHumSensor_getTemperature()/100);
	memset(str1,0,sizeof(str1));
	sprintf(str1,"Temp = %d oC   ",temperture);
	ucg_DrawString(&ucg,5,52,0,str1);

	humidity =(uint8_t) TemHumSensor_getHumidity();
	memset(str2,0,sizeof(str2));
	sprintf(str2,"Humi = %d %%   ",humidity);
	ucg_DrawString(&ucg,5,82,0,str2);
}
int main(void)
{
	SystemCoreClockUpdate();
	TimerInit();
	I2C_InitMaster();
	Ucglib4WireSWSPI_begin(&ucg, UCG_FONT_MODE_SOLID);
	ucg_ClearScreen(&ucg);
	ucg_SetFont(&ucg,ucg_font_ncenR12_hr);
	ucg_SetColor(&ucg,0,255,255,255);
	ucg_SetColor(&ucg,1,0,0,0);
	ucg_SetRotate180(&ucg);
	ucg_DrawString(&ucg,15,22,0,"Assignment 2");
	time_initial = GetMilSecTick();
	if(Sensor!=NO_TIMER)
	{
		TimerStop(Sensor);
	}
	Sensor = TimerStart("Task_multiSensorScan",1000,TIMER_REPEAT_FOREVER,processGetValueSensor,NULL);
	while(1)
	{
		processTimerScheduler();
	}
	return 0;
}
